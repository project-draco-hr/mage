{
  if (ui == null) {
    throw new RuntimeException("Error: no components");
  }
  JComponent component=ui.get("battlefieldPanel");
  if (component == null) {
    throw new RuntimeException("Error: battlefieldPanel is missing");
  }
  JLayeredPane battlefieldPanel=(JLayeredPane)component;
  JComponent jPanel=ui.get("jPanel");
  Row rowAllLands=new Row();
  outerLoop:   for (  MagePermanent permanent : permanents) {
    if (!CardUtil.isLand(permanent) || CardUtil.isCreature(permanent)) {
      continue;
    }
    int insertIndex=-1;
    for (int i=0, n=rowAllLands.size(); i < n; i++) {
      Stack stack=rowAllLands.get(i);
      MagePermanent firstPanel=stack.get(0);
      if (firstPanel.getOriginal().getName().equals(permanent.getOriginal().getName())) {
        if (!empty(firstPanel.getOriginalPermanent().getAttachments())) {
          insertIndex=i;
          break;
        }
        List<CounterView> counters=firstPanel.getOriginalPermanent().getCounters();
        if (counters != null && counters.size() > 0) {
          insertIndex=i;
          break;
        }
        if (!empty(permanent.getOriginalPermanent().getAttachments()) || stack.size() == landStackMax) {
          insertIndex=i + 1;
          continue;
        }
        counters=permanent.getOriginalPermanent().getCounters();
        if (counters != null && counters.size() > 0) {
          insertIndex=i + 1;
          continue;
        }
        stack.add(0,permanent);
        continue outerLoop;
      }
      if (insertIndex != -1) {
        break;
      }
    }
    Stack stack=new Stack();
    if (permanent.getOriginalPermanent().getAttachments() != null) {
      stack.setMaxAttachedCount(permanent.getOriginalPermanent().getAttachments().size());
    }
    stack.add(permanent);
    rowAllLands.add(insertIndex == -1 ? rowAllLands.size() : insertIndex,stack);
  }
  Row rowAllCreatures=new Row(permanents,RowType.creature);
  Row rowAllOthers=new Row(permanents,RowType.other);
  Row rowAllAttached=new Row(permanents,RowType.attached);
  boolean othersOnTheRight=true;
  if (options != null && options.containsKey("nonLandPermanentsInOnePile")) {
    if (options.get("nonLandPermanentsInOnePile").equals("true")) {
      othersOnTheRight=false;
      rowAllCreatures.addAll(rowAllOthers);
      rowAllOthers.clear();
    }
  }
  cardWidth=cardWidthMax;
  Rectangle rect=battlefieldPanel.getVisibleRect();
  playAreaWidth=rect.width;
  playAreaHeight=rect.height;
  while (true) {
    rows.clear();
    cardHeight=Math.round(cardWidth * CardPanel.ASPECT_RATIO);
    extraCardSpacingX=Math.round(cardWidth * EXTRA_CARD_SPACING_X);
    cardSpacingX=cardHeight - cardWidth + extraCardSpacingX;
    cardSpacingY=Math.round(cardHeight * CARD_SPACING_Y);
    stackSpacingX=stackVertical ? 0 : Math.round(cardWidth * STACK_SPACING_X);
    stackSpacingY=Math.round(cardHeight * STACK_SPACING_Y);
    attachmentSpacingY=Math.round(cardHeight * ATTACHMENT_SPACING_Y);
    Row creatures=(Row)rowAllCreatures.clone();
    Row lands=(Row)rowAllLands.clone();
    Row others=(Row)rowAllOthers.clone();
    wrap(creatures,rows,-1);
    int afterCreaturesIndex=rows.size();
    wrap(lands,rows,afterCreaturesIndex);
    int afterLandsIndex=rows.size();
    wrap(others,rows,afterLandsIndex);
    List<Row> storedRows=new ArrayList<>(rows.size());
    for (    Row row : rows) {
      storedRows.add((Row)row.clone());
    }
    Row storedOthers=(Row)others.clone();
    for (    Row row : rows) {
      fillRow(others,rows,row);
    }
    if (creatures.isEmpty() && lands.isEmpty() && others.isEmpty()) {
      break;
    }
    rows=storedRows;
    others=storedOthers;
    wrap(others,rows,afterCreaturesIndex);
    for (    Row row : rows) {
      fillRow(others,rows,row);
    }
    if (creatures.isEmpty() && lands.isEmpty() && others.isEmpty()) {
      break;
    }
    cardWidth-=3;
  }
  int x, y=GUTTER_Y;
  int maxRowWidth=0;
  for (  Row row : rows) {
    int rowBottom=0;
    x=GUTTER_X;
    for (int stackIndex=0, stackCount=row.size(); stackIndex < stackCount; stackIndex++) {
      Stack stack=row.get(stackIndex);
      rowBottom=Math.max(rowBottom,y + stack.getHeight());
      x+=stack.getWidth();
    }
    y=rowBottom;
    maxRowWidth=Math.max(maxRowWidth,x);
  }
  y=GUTTER_Y;
  for (  Row row : rows) {
    int rowBottom=0;
    x=GUTTER_X;
    for (int stackIndex=0, stackCount=row.size(); stackIndex < stackCount; stackIndex++) {
      Stack stack=row.get(stackIndex);
      if (othersOnTheRight && RowType.other.isType(stack.get(0))) {
        x=playAreaWidth - GUTTER_X + extraCardSpacingX;
        for (int i=stackIndex, n=row.size(); i < n; i++) {
          x-=row.get(i).getWidth();
        }
      }
      for (int panelIndex=0, panelCount=stack.size(); panelIndex < panelCount; panelIndex++) {
        MagePermanent panel=stack.get(panelIndex);
        int stackPosition=panelCount - panelIndex - 1;
        if (jPanel != null) {
          jPanel.setComponentZOrder(panel,panelIndex);
        }
        int panelX=x + (stackPosition * stackSpacingX);
        int panelY=y + (stackPosition * stackSpacingY);
        try {
          battlefieldPanel.moveToFront(panel);
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
        panel.setCardBounds(panelX,panelY,cardWidth,cardHeight);
      }
      rowBottom=Math.max(rowBottom,y + stack.getHeight());
      x+=stack.getWidth();
    }
    y=rowBottom;
  }
  for (  Stack stack : rowAllAttached) {
    for (    MagePermanent panel : stack) {
      panel.setCardBounds(0,0,cardWidth,cardHeight);
    }
  }
  return y;
}
