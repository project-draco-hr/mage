{
  Player createdForPlayer=null;
  this.isPlayer=createdForPlayerId != null;
  this.priorityTime=game.getPriorityTime();
  for (  Player player : state.getPlayers().values()) {
    players.add(new PlayerView(player,state,game,createdForPlayerId,watcherUserId));
    if (player.getId().equals(createdForPlayerId)) {
      createdForPlayer=player;
    }
  }
  for (  StackObject stackObject : state.getStack()) {
    if (stackObject instanceof StackAbility) {
      MageObject object=game.getObject(stackObject.getSourceId());
      Card card=game.getCard(stackObject.getSourceId());
      if (card != null) {
        if (object != null) {
          stack.put(stackObject.getId(),new StackAbilityView(game,(StackAbility)stackObject,card.getName(),new CardView(card)));
        }
 else {
          stack.put(stackObject.getId(),new StackAbilityView(game,(StackAbility)stackObject,"",new CardView(card)));
        }
        if (card.canTransform()) {
          updateLatestCardView(game,card,stackObject.getId());
        }
        checkPaid(stackObject.getId(),(StackAbility)stackObject);
      }
 else       if (object != null) {
        if (object instanceof PermanentToken) {
          PermanentToken token=(PermanentToken)object;
          stack.put(stackObject.getId(),new StackAbilityView(game,(StackAbility)stackObject,token.getName(),new CardView(token)));
          checkPaid(stackObject.getId(),(StackAbility)stackObject);
        }
 else         if (object instanceof Emblem) {
          Card sourceCard=game.getCard(((Emblem)object).getSourceId());
          if (sourceCard != null) {
            ((StackAbility)stackObject).setName("Emblem " + sourceCard.getName());
            ((StackAbility)stackObject).setExpansionSetCode(sourceCard.getExpansionSetCode());
          }
 else {
            throw new IllegalArgumentException("Source card for emblem not found.");
          }
          stack.put(stackObject.getId(),new StackAbilityView(game,(StackAbility)stackObject,object.getName(),new CardView(new EmblemView(((Emblem)object),sourceCard))));
          checkPaid(stackObject.getId(),((StackAbility)stackObject));
        }
 else {
          StackAbility stackAbility=((StackAbility)object);
          stackAbility.newId();
          stack.put(stackObject.getId(),new CardView(((StackAbility)stackObject)));
          checkPaid(stackObject.getId(),((StackAbility)stackObject));
        }
      }
 else {
        logger.error("Stack Object for stack ability not found: " + stackObject.getStackAbility().getRule());
      }
    }
 else {
      stack.put(stackObject.getId(),new CardView((Spell)stackObject,game,null,stackObject.getControllerId().equals(createdForPlayerId)));
      checkPaid(stackObject.getId(),(Spell)stackObject);
    }
  }
  for (  ExileZone exileZone : state.getExile().getExileZones()) {
    exiles.add(new ExileView(exileZone,game));
  }
  for (  String name : state.getRevealed().keySet()) {
    revealed.add(new RevealedView(name,state.getRevealed().get(name),game));
  }
  this.phase=state.getTurn().getPhaseType();
  this.step=state.getTurn().getStepType();
  this.turn=state.getTurnNum();
  this.activePlayerId=state.getActivePlayerId();
  if (state.getActivePlayerId() != null) {
    this.activePlayerName=state.getPlayer(state.getActivePlayerId()).getName();
  }
 else {
    this.activePlayerName="";
  }
  if (state.getPriorityPlayerId() != null) {
    this.priorityPlayerName=state.getPlayer(state.getPriorityPlayerId()).getName();
  }
 else {
    this.priorityPlayerName="";
  }
  for (  CombatGroup combatGroup : state.getCombat().getGroups()) {
    combat.add(new CombatGroupView(combatGroup,game));
  }
  if (isPlayer) {
    if (state.getPriorityPlayerId() == createdForPlayerId && createdForPlayer != null) {
      this.special=state.getSpecialActions().getControlledBy(state.getPriorityPlayerId(),createdForPlayer.isInPayManaMode()).size() > 0;
    }
  }
 else {
    this.special=false;
  }
  CastSpellLastTurnWatcher watcher=(CastSpellLastTurnWatcher)game.getState().getWatchers().get("CastSpellLastTurnWatcher");
  if (watcher != null) {
    spellsCastCurrentTurn=watcher.getAmountOfSpellsAllPlayersCastOnCurrentTurn();
  }
 else {
    spellsCastCurrentTurn=0;
  }
}
