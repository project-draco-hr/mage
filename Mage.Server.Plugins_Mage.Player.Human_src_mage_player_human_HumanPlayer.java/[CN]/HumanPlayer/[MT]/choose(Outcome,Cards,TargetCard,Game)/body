{
  updateGameStatePriority("choose(4)",game);
  while (!abort) {
    boolean required=target.isRequired();
    if (cards == null) {
      required=false;
    }
 else {
      int count=cards.count(target.getFilter(),game);
      if (count == 0) {
        required=false;
      }
    }
    if (target.getTargets().size() >= target.getNumberOfTargets()) {
      required=false;
    }
    Map<String,Serializable> options=getOptions(target,null);
    List<UUID> chosen=target.getTargets();
    options.put("chosen",(Serializable)chosen);
    List<UUID> choosable=new ArrayList<>();
    for (    UUID cardId : cards) {
      if (target.canTarget(cardId,cards,game)) {
        choosable.add(cardId);
      }
    }
    if (!choosable.isEmpty()) {
      options.put("choosable",(Serializable)choosable);
    }
    game.fireSelectTargetEvent(playerId,target.getMessage(),cards,required,options);
    waitForResponse(game);
    if (response.getUUID() != null) {
      if (target.canTarget(response.getUUID(),cards,game)) {
        if (target.getTargets().contains(response.getUUID())) {
          target.remove(response.getUUID());
        }
 else {
          target.add(response.getUUID(),game);
          if (target.doneChosing()) {
            return true;
          }
        }
      }
    }
 else {
      if (target.getTargets().size() >= target.getNumberOfTargets()) {
        return true;
      }
      if (!required) {
        return false;
      }
    }
  }
  return false;
}
