{
  log.debug("priority");
  UUID opponentId=game.getOpponents(playerId).iterator().next();
  if (game.getActivePlayerId().equals(playerId)) {
    if (game.isMainPhase() && game.getStack().isEmpty()) {
      playLand(game);
    }
switch (game.getTurn().getStepType()) {
case UPKEEP:
      findPlayables(game);
    break;
case DRAW:
  logState(game);
break;
case PRECOMBAT_MAIN:
findPlayables(game);
if (playableAbilities.size() > 0) {
for (ActivatedAbility ability : playableAbilities) {
if (ability.canActivate(playerId,game)) {
  if (ability.getEffects().hasOutcome(Outcome.PutLandInPlay)) {
    if (this.activateAbility(ability,game))     return;
  }
  if (ability.getEffects().hasOutcome(Outcome.PutCreatureInPlay)) {
    if (getOpponentBlockers(opponentId,game).size() <= 1)     if (this.activateAbility(ability,game))     return;
  }
}
}
}
break;
case DECLARE_BLOCKERS:
findPlayables(game);
playRemoval(game.getCombat().getBlockers(),game);
playDamage(game.getCombat().getBlockers(),game);
break;
case END_COMBAT:
findPlayables(game);
playDamage(game.getCombat().getBlockers(),game);
break;
case POSTCOMBAT_MAIN:
findPlayables(game);
if (game.getStack().isEmpty()) {
if (playableNonInstant.size() > 0) {
for (Card card : playableNonInstant) {
if (card.getSpellAbility().canActivate(playerId,game)) {
if (this.activateAbility(card.getSpellAbility(),game)) return;
}
}
}
if (playableAbilities.size() > 0) {
for (ActivatedAbility ability : playableAbilities) {
if (ability.canActivate(playerId,game)) {
if (!(ability.getEffects().get(0) instanceof BecomesCreatureSourceEffect)) {
if (this.activateAbility(ability,game)) return;
}
}
}
}
}
break;
}
}
 else {
switch (game.getTurn().getStepType()) {
case UPKEEP:
findPlayables(game);
break;
case DECLARE_ATTACKERS:
findPlayables(game);
playRemoval(game.getCombat().getAttackers(),game);
playDamage(game.getCombat().getAttackers(),game);
break;
case END_COMBAT:
findPlayables(game);
playDamage(game.getCombat().getAttackers(),game);
break;
}
}
pass();
}
