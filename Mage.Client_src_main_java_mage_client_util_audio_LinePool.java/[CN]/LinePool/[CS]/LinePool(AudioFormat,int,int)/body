{
  threadPool=new ThreadPoolExecutor(alwaysActive,size,30L,TimeUnit.SECONDS,new LinkedBlockingQueue(),new ThreadFactory(){
    @Override public Thread newThread(    Runnable runnable){
      threadCount++;
      Thread thread=new Thread(runnable,"Audio" + threadCount);
      thread.setDaemon(true);
      return thread;
    }
  }
);
  threadPool.prestartAllCoreThreads();
  format=audioFormat;
  this.alwaysActive=alwaysActive;
  mixer=AudioSystem.getMixer(null);
  DataLine.Info lineInfo=new DataLine.Info(SourceDataLine.class,audioFormat);
  for (int i=0; i < size; i++) {
    try {
      SourceDataLine line=(SourceDataLine)mixer.getLine(lineInfo);
      freeLines.add(line);
    }
 catch (    LineUnavailableException e) {
      e.printStackTrace();
    }
  }
  new Timer("Line cleanup",true).scheduleAtFixedRate(new TimerTask(){
    @Override public void run(){
synchronized (LinePool.this) {
        for (        SourceDataLine sourceDataLine : freeLines) {
          if (sourceDataLine.isOpen()) {
            sourceDataLine.close();
            log.debug("Closed line {}",sourceDataLine);
          }
        }
      }
    }
  }
,LINE_CLEANUP_INTERVAL,LINE_CLEANUP_INTERVAL);
}
