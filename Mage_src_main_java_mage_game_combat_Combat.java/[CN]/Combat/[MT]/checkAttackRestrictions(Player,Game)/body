{
  boolean check=true;
  int numberOfChecks=0;
  UUID attackerToRemove=null;
  Check:   while (check) {
    check=false;
    numberOfChecks++;
    int numberAttackers=0;
    for (    CombatGroup group : groups) {
      numberAttackers+=group.getAttackers().size();
    }
    Player attackingPlayer=game.getPlayer(attackerId);
    if (attackerToRemove != null) {
      removeAttacker(attackerToRemove,game);
    }
    for (    UUID attackingCreatureId : this.getAttackers()) {
      Permanent attackingCreature=game.getPermanent(attackingCreatureId);
      for (      Map.Entry<RestrictionEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRestrictionEffects(attackingCreature,game).entrySet()) {
        RestrictionEffect effect=entry.getKey();
        for (        Ability ability : entry.getValue()) {
          if (!effect.canAttackCheckAfter(numberAttackers,ability,game)) {
            MageObject sourceObject=ability.getSourceObject(game);
            if (attackingPlayer.isHuman()) {
              game.informPlayer(attackingPlayer,attackingCreature.getIdName() + " can't attack this way (" + (sourceObject == null ? "null" : sourceObject.getIdName())+ ")");
              return false;
            }
 else {
              for (              CombatGroup combatGroup : this.getGroups()) {
                if (combatGroup.getAttackers().contains(attackingCreatureId)) {
                  attackerToRemove=attackingCreatureId;
                }
              }
              check=true;
              if (numberOfChecks > 50) {
                logger.error("Seems to be an AI declare attacker lock (reached 50 check iterations) " + (sourceObject == null ? "null" : sourceObject.getIdName()));
                return true;
              }
              continue Check;
            }
          }
        }
      }
    }
  }
  return true;
}
