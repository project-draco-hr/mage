{
  game.fireEvent(new GameEvent(GameEvent.EventType.DECLARE_ATTACKERS_STEP_PRE,null,null,activePlayerId));
  if (!game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.DECLARING_ATTACKERS,activePlayerId,activePlayerId))) {
    Player attackingPlayer=game.getPlayer(activePlayerId);
    UUID defenderId=game.getOpponents(playerId).iterator().next();
    Player defender=game.getPlayer(defenderId);
    List<Permanent> attackersList=super.getAvailableAttackers(game);
    if (attackersList.isEmpty()) {
      return;
    }
    List<Permanent> possibleBlockers=defender.getAvailableBlockers(game);
    List<Permanent> killers=CombatUtil.canKillOpponent(game,attackersList,possibleBlockers,defender);
    if (!killers.isEmpty()) {
      for (      Permanent attacker : killers) {
        attackingPlayer.declareAttacker(attacker.getId(),defenderId,game);
      }
      return;
    }
    CombatUtil.handleExalted();
    List<Permanent> counterAttackList=new ArrayList<Permanent>();
    int counterAttackDamage=0;
    int defenderForces=0;
    int defenderForcesForBlock=0;
    FilterCreatureForCombat filter=new FilterCreatureForCombat();
    for (    Permanent possibleAttacker : game.getBattlefield().getAllActivePermanents(filter,defender.getId())) {
      if (!possibleAttacker.getAbilities().contains(DefenderAbility.getInstance())) {
        counterAttackList.add(possibleAttacker);
        if (possibleAttacker.getPower().getValue() > 0) {
          counterAttackDamage+=possibleAttacker.getPower().getValue();
          defenderForces++;
        }
        if (CombatUtil.canBlock(game,possibleAttacker)) {
          defenderForcesForBlock++;
        }
      }
    }
    double oppScore=1000000;
    if (counterAttackDamage > 0) {
      oppScore=(double)attackingPlayer.getLife() / counterAttackDamage;
    }
    List<Permanent> possibleAttackersList=new ArrayList<Permanent>();
    int possibleAttackersDamage=0;
    int ourForces=0;
    for (    Permanent possibleAttacker : game.getBattlefield().getAllActivePermanents(filter,playerId)) {
      if (!possibleAttacker.getAbilities().contains(DefenderAbility.getInstance())) {
        possibleAttackersList.add(possibleAttacker);
        if (possibleAttacker.getPower().getValue() > 0) {
          possibleAttackersDamage+=possibleAttacker.getPower().getValue();
          ourForces++;
        }
      }
    }
    double ourScore=1000000;
    if (possibleAttackersDamage > 0) {
      ourScore=(double)defender.getLife() / possibleAttackersDamage;
    }
    int outNumber=ourForces - defenderForces;
    double score=ourScore - oppScore;
    boolean doAttack=false;
    CombatUtil.sortByPower(attackersList,false);
    int opponentLife=defender.getLife();
    List<Permanent> notBlockedAttackers=new ArrayList<Permanent>();
    for (int i=0; i < (attackersList.size() - defenderForces); i++) {
      notBlockedAttackers.add(attackersList.get(i));
    }
    int attackRound=1;
    while (notBlockedAttackers.size() > 0 && opponentLife > 0 && attackRound < 99) {
      int damageThisRound=0;
      for (      Permanent attacker : notBlockedAttackers) {
        damageThisRound+=attacker.getPower().getValue();
      }
      opponentLife-=damageThisRound;
      for (int i=0; i < defenderForcesForBlock && !notBlockedAttackers.isEmpty(); i++) {
        notBlockedAttackers.remove(notBlockedAttackers.size() - 1);
      }
      attackRound++;
      if (opponentLife <= 0) {
        doAttack=true;
      }
    }
    double unblockableDamage=0;
    double turnsUntilDeathByUnblockable=0;
    boolean doUnblockableAttack=false;
    for (    Permanent attacker : attackersList) {
      boolean isUnblockableCreature=true;
      for (      Permanent blocker : possibleBlockers) {
        if (blocker.canBlock(attacker.getId(),game)) {
          isUnblockableCreature=false;
        }
      }
      if (isUnblockableCreature) {
        unblockableDamage+=attacker.getPower().getValue();
      }
    }
    if (unblockableDamage > 0) {
      turnsUntilDeathByUnblockable=defender.getLife() / unblockableDamage;
    }
    if (unblockableDamage > defender.getLife()) {
      doUnblockableAttack=true;
    }
    int aggressionRate=5;
    System.out.println("AI aggression = " + String.valueOf(aggressionRate));
    System.out.println("AI attackers size: " + attackersList.size());
    List<Permanent> finalAttackers=new ArrayList<Permanent>();
    for (int i=0; i < attackersList.size(); i++) {
      Permanent attacker=attackersList.get(i);
      int totalFirstStrikeBlockPower=0;
      if (!attacker.getAbilities().contains(FirstStrikeAbility.getInstance()) && !attacker.getAbilities().contains(DoubleStrikeAbility.getInstance())) {
        for (        Permanent blockerWithFSorDB : game.getBattlefield().getAllActivePermanents(filter,playerId)) {
          if (blockerWithFSorDB.getAbilities().contains(DoubleStrikeAbility.getInstance())) {
            totalFirstStrikeBlockPower+=2 * blockerWithFSorDB.getPower().getValue();
          }
 else           if (blockerWithFSorDB.getAbilities().contains(FirstStrikeAbility.getInstance())) {
            totalFirstStrikeBlockPower+=blockerWithFSorDB.getPower().getValue();
          }
        }
      }
      boolean shouldAttack=shouldAttack(game,attackingPlayer.getId(),defenderId,attacker,possibleBlockers,aggressionRate);
      if (aggressionRate == 5 || shouldAttack && (totalFirstStrikeBlockPower < attacker.getToughness().getValue())) {
        finalAttackers.add(attacker);
      }
    }
    System.out.println("AI final attackers size: " + attackersList.size());
    for (    Permanent attacker : finalAttackers) {
      attackingPlayer.declareAttacker(attacker.getId(),defenderId,game);
    }
  }
}
