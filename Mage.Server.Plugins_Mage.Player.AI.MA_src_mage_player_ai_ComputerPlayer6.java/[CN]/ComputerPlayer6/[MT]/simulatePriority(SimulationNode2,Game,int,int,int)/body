{
  if (ALLOW_INTERRUPT && Thread.interrupted()) {
    Thread.currentThread().interrupt();
    logger.info("interrupted");
    return GameStateEvaluator2.evaluate(playerId,game);
  }
  node.setGameValue(game.getState().getValue(true).hashCode());
  SimulatedPlayer2 currentPlayer=(SimulatedPlayer2)game.getPlayer(game.getPlayerList().get());
  SimulationNode2 bestNode=null;
  List<Ability> allActions=currentPlayer.simulatePriority(game);
  optimize(game,allActions);
  if (logger.isInfoEnabled() && allActions.size() > 0 && depth == maxDepth) {
    logger.info("ADDED ACTIONS (" + allActions.size() + ") "+ " "+ allActions);
  }
  int counter=0;
  int bestValSubNodes=Integer.MIN_VALUE;
  for (  Ability action : allActions) {
    counter++;
    if (ALLOW_INTERRUPT && Thread.interrupted()) {
      Thread.currentThread().interrupt();
      logger.info("Sim Prio [" + depth + "] -- interrupted");
      break;
    }
    Game sim=game.copy();
    sim.setSimulation(true);
    if (sim.getPlayer(currentPlayer.getId()).activateAbility((ActivatedAbility)action.copy(),sim)) {
      sim.applyEffects();
      if (checkForRepeatedAction(sim,node,action,currentPlayer.getId())) {
        logger.debug("Sim Prio [" + depth + "] -- repeated action: "+ action.toString());
        continue;
      }
      if (!sim.gameOver(null) && action.isUsesStack()) {
        UUID nextPlayerId=sim.getPlayerList().get();
        do {
          sim.getPlayer(nextPlayerId).pass(game);
          nextPlayerId=sim.getPlayerList().getNext();
        }
 while (nextPlayerId != this.getId());
      }
      SimulationNode2 newNode=new SimulationNode2(node,sim,action,depth,currentPlayer.getId());
      sim.checkStateAndTriggered();
      int val;
      if (action instanceof PassAbility) {
        val=GameStateEvaluator2.evaluate(this.getId(),sim);
      }
 else {
        val=addActions(newNode,depth - 1,alpha,beta);
      }
      logger.debug("Sim Prio " + BLANKS.substring(0,2 + (maxDepth - depth) * 3) + "["+ depth+ "]#"+ counter+ " <"+ val+ "> - ("+ action.toString()+ ") ");
      if (logger.isInfoEnabled() && depth >= maxDepth) {
        StringBuilder sb=new StringBuilder("Sim Prio [").append(depth).append("] #").append(counter).append(" <").append(val).append("> (").append(action).append(action.isModal() ? " Mode = " + action.getModes().getMode().toString() : "").append(listTargets(game,action.getTargets())).append(")").append(logger.isTraceEnabled() ? " #" + newNode.hashCode() : "");
        SimulationNode2 logNode=newNode;
        while (logNode.getChildren() != null && logNode.getChildren().size() > 0) {
          logNode=logNode.getChildren().get(0);
          if (logNode.getAbilities() != null && logNode.getAbilities().size() > 0) {
            sb.append(" -> [").append(logNode.getDepth()).append("]").append(logNode.getAbilities().toString()).append("<").append(logNode.getScore()).append(">");
          }
        }
        logger.info(sb);
      }
      if (currentPlayer.getId().equals(playerId)) {
        if (val > bestValSubNodes) {
          bestValSubNodes=val;
        }
        if (depth == maxDepth && action instanceof PassAbility) {
          val=val - PASSIVITY_PENALTY;
        }
        if (val > alpha || (depth == maxDepth && val == alpha && RandomUtil.nextBoolean())) {
          alpha=val;
          bestNode=newNode;
          bestNode.setScore(val);
          if (newNode.getChildren().size() > 0) {
            bestNode.setCombat(newNode.getChildren().get(0).getCombat());
          }
          if (depth == maxDepth) {
            logger.info("Sim Prio [" + depth + "] -- Saved best node yet <"+ bestNode.getScore()+ "> "+ bestNode.getAbilities().toString());
            node.children.clear();
            node.children.add(bestNode);
            node.setScore(bestNode.getScore());
          }
        }
        if (val == GameStateEvaluator2.WIN_GAME_SCORE) {
          logger.debug("Sim Prio -- win - break");
          break;
        }
      }
 else {
        if (val < beta) {
          beta=val;
          bestNode=newNode;
          bestNode.setScore(val);
          if (newNode.getChildren().size() > 0) {
            bestNode.setCombat(newNode.getChildren().get(0).getCombat());
          }
        }
        if (val == GameStateEvaluator2.LOSE_GAME_SCORE) {
          logger.debug("Sim Prio -- lose - break");
          break;
        }
      }
      if (alpha >= beta) {
        break;
      }
      if (SimulationNode2.nodeCount > maxNodes) {
        logger.debug("Sim Prio -- reached end-state");
        break;
      }
    }
  }
  if (depth == maxDepth) {
    logger.info(new StringBuilder("Sim Prio [").append(depth).append("] -- End for Max Depth  -- Nodes calculated: ").append(SimulationNode2.nodeCount));
  }
  if (bestNode != null) {
    node.children.clear();
    node.children.add(bestNode);
    node.setScore(bestNode.getScore());
    if (logger.isTraceEnabled() && !bestNode.getAbilities().toString().equals("[Pass]")) {
      logger.trace(new StringBuilder("Sim Prio [").append(depth).append("] -- Set after (depth=").append(depth).append(")  <").append(bestNode.getScore()).append("> ").append(bestNode.getAbilities().toString()).toString());
    }
  }
  if (currentPlayer.getId().equals(playerId)) {
    return bestValSubNodes;
  }
 else {
    return beta;
  }
}
